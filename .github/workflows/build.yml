name: Build

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]
  workflow_dispatch:

jobs:
  build:
    name: Build OnCall Notify
    runs-on: macos-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Select Xcode version
        run: |
          XCODE_PATH=$(ls -td /Applications/Xcode_*.app | head -1)
          if [ -z "$XCODE_PATH" ]; then
            XCODE_PATH="/Applications/Xcode.app"
          fi
          echo "Using Xcode at: $XCODE_PATH"
          sudo xcode-select -s "$XCODE_PATH/Contents/Developer"

      - name: Show build environment
        run: |
          echo "Xcode version:"
          xcodebuild -version
          echo ""
          echo "Swift version:"
          swift --version
          echo ""
          echo "macOS version:"
          sw_vers

      - name: Verify icon files before build
        run: |
          echo "Checking icon files..."
          ICON_DIR="OnCallNotify/Assets.xcassets/AppIcon.appiconset"

          if [ ! -d "$ICON_DIR" ]; then
            echo "âœ— Icon directory not found: $ICON_DIR"
            exit 1
          fi
          echo "âœ“ Icon directory found"

          ICON_COUNT=$(ls -1 "$ICON_DIR"/*.png 2>/dev/null | wc -l | xargs)
          if [ "$ICON_COUNT" -ne 7 ]; then
            echo "âœ— Expected 7 icon files, found $ICON_COUNT"
            ls -1 "$ICON_DIR"/*.png 2>/dev/null || echo "No PNG files found"
            exit 1
          fi
          echo "âœ“ All 7 icon files present"

          if [ ! -f "$ICON_DIR/Contents.json" ]; then
            echo "âœ— Contents.json not found"
            exit 1
          fi
          echo "âœ“ Contents.json found"

          # Verify Contents.json is valid JSON
          if ! python3 -m json.tool "$ICON_DIR/Contents.json" > /dev/null 2>&1; then
            echo "âœ— Contents.json is not valid JSON"
            exit 1
          fi
          echo "âœ“ Contents.json is valid JSON"

          # Verify each PNG file is valid
          for icon in "$ICON_DIR"/*.png; do
            if ! file "$icon" | grep -q "PNG image data"; then
              echo "âœ— Invalid PNG file: $icon"
              exit 1
            fi
          done
          echo "âœ“ All icon PNG files are valid"

          echo "âœ… Icon files verification complete"

      # Sign all branch pushes and manual builds (not PRs, to avoid requiring secrets for external contributors)
      - name: Setup code signing
        if: github.event_name != 'pull_request'
        env:
          CERTIFICATE_BASE64: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}
          CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          # Create a temporary keychain with a password we control
          KEYCHAIN_NAME="build.keychain"
          KEYCHAIN_PASSWORD="temporary_password_$(uuidgen)"
          KEYCHAIN_PATH="$HOME/Library/Keychains/$KEYCHAIN_NAME-db"

          echo "Creating temporary keychain..."
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"

          # Set keychain settings - no timeout, no lock
          echo "Configuring keychain settings..."
          security set-keychain-settings "$KEYCHAIN_NAME"

          # Unlock the keychain
          echo "Unlocking keychain..."
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"

          # Add to keychain search list
          echo "Adding to keychain search list..."
          security list-keychains -d user -s "$KEYCHAIN_NAME" $(security list-keychains -d user | sed s/\"//g)

          # Import certificate
          echo "Importing certificate..."
          CERTIFICATE_PATH=$RUNNER_TEMP/certificate.p12
          echo "$CERTIFICATE_BASE64" | base64 --decode > "$CERTIFICATE_PATH"

          # Verify certificate file was created
          if [ ! -f "$CERTIFICATE_PATH" ]; then
            echo "Error: Certificate file was not created"
            exit 1
          fi

          echo "Certificate file size: $(ls -lh "$CERTIFICATE_PATH" | awk '{print $5}')"

          # Verify it's a valid PKCS12 file
          if ! file "$CERTIFICATE_PATH" | grep -q "data"; then
            echo "Error: Certificate file doesn't appear to be valid"
            file "$CERTIFICATE_PATH"
            exit 1
          fi

          # Import certificate with -T flags for codesign and security tools
          echo "Importing certificate to keychain..."
          security import "$CERTIFICATE_PATH" \
            -P "$CERTIFICATE_PASSWORD" \
            -A \
            -t cert \
            -f pkcs12 \
            -k "$KEYCHAIN_NAME" \
            -T /usr/bin/codesign \
            -T /usr/bin/security || {
              echo "Error: Certificate import failed"
              echo "This usually means:"
              echo "1. APPLE_CERTIFICATE_PASSWORD is incorrect"
              echo "2. APPLE_CERTIFICATE_BASE64 is not a valid .p12 file"
              echo "3. The certificate doesn't contain a private key"
              exit 1
            }

          # Set partition list to allow access without password prompt
          echo "Setting partition list for codesign access..."
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"

          # Verify certificate and get exact identity
          echo "Installed certificates:"
          security find-identity -v -p codesigning "$KEYCHAIN_NAME"

          # Count how many identities we have
          IDENTITY_COUNT=$(security find-identity -v -p codesigning "$KEYCHAIN_NAME" | grep -c "Developer ID Application" || echo "0")
          echo "Found $IDENTITY_COUNT Developer ID Application certificate(s)"

          if [ "$IDENTITY_COUNT" -eq "0" ]; then
            echo "Error: No Developer ID Application certificate found after import"
            echo "The certificate import succeeded but no codesigning identity is available"
            echo "Please verify your certificate export includes the private key"
            exit 1
          fi

          # Extract the exact identity for use in xcodebuild
          IDENTITY=$(security find-identity -v -p codesigning "$KEYCHAIN_NAME" | grep "Developer ID Application" | head -1 | sed -n 's/.*"\(.*\)"/\1/p')
          echo "Found identity: $IDENTITY"

          if [ -z "$IDENTITY" ]; then
            echo "Error: Could not extract identity name"
            exit 1
          fi

          # Extract team ID from identity string (it's in parentheses)
          # Example: "Developer ID Application: Company Name (TEAM123)" -> "TEAM123"
          echo "Extracting team ID from identity string..."
          CERT_TEAM_ID=$(echo "$IDENTITY" | sed -n 's/.*(\([^)]*\)).*/\1/p')

          if [ -z "$CERT_TEAM_ID" ]; then
            echo "Warning: Could not extract team ID from identity, using provided value"
            CERT_TEAM_ID="$TEAM_ID"
          else
            echo "Extracted team ID from identity: $CERT_TEAM_ID"
          fi

          # Store the exact identity name, team ID, and keychain info for the build step
          echo "SIGNING_IDENTITY=$IDENTITY" >> $GITHUB_ENV
          echo "CERT_TEAM_ID=$CERT_TEAM_ID" >> $GITHUB_ENV
          echo "KEYCHAIN_NAME=$KEYCHAIN_NAME" >> $GITHUB_ENV
          echo "KEYCHAIN_PASSWORD=$KEYCHAIN_PASSWORD" >> $GITHUB_ENV

          echo "âœ… Code signing certificate installed"

      - name: Build (Debug)
        if: github.event_name == 'pull_request'
        run: |
          xcodebuild \
            -project OnCallNotify.xcodeproj \
            -scheme OnCallNotify \
            -configuration Debug \
            -derivedDataPath build/DerivedData \
            CODE_SIGNING_ALLOWED=NO \
            build

      - name: Build (Release - Unsigned)
        if: github.event_name == 'pull_request'
        run: |
          xcodebuild \
            -project OnCallNotify.xcodeproj \
            -scheme OnCallNotify \
            -configuration Release \
            -derivedDataPath build/DerivedData \
            CODE_SIGNING_ALLOWED=NO \
            build

      - name: Build (Release - Signed)
        if: github.event_name != 'pull_request'
        run: |
          echo "Building with Developer ID Application certificate for team: $CERT_TEAM_ID"

          # Verify certificate is accessible
          echo "Verifying certificate in login keychain:"
          security find-identity -v -p codesigning

          echo "Using signing identity: $SIGNING_IDENTITY"
          echo "Using team ID: $CERT_TEAM_ID"

          # Unlock keychain before build (in case it locked)
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"

          # Build with signing
          xcodebuild \
            -project OnCallNotify.xcodeproj \
            -scheme OnCallNotify \
            -configuration Release \
            -derivedDataPath build/DerivedData \
            CODE_SIGN_IDENTITY="$SIGNING_IDENTITY" \
            CODE_SIGN_STYLE=Manual \
            DEVELOPMENT_TEAM="$CERT_TEAM_ID" \
            ENABLE_HARDENED_RUNTIME=YES \
            CODE_SIGN_ENTITLEMENTS="OnCallNotify/OnCallNotify.entitlements" \
            CODE_SIGN_INJECT_BASE_ENTITLEMENTS=NO \
            OTHER_CODE_SIGN_FLAGS="--keychain $KEYCHAIN_NAME --options runtime --timestamp" \
            build

      - name: Find built app
        id: find-app
        run: |
          APP_PATH=$(find build/DerivedData/Build/Products -name "OnCallNotify.app" -type d | head -n 1)
          echo "app_path=$APP_PATH" >> $GITHUB_OUTPUT
          echo "Found app at: $APP_PATH"

      - name: Verify code signature
        if: github.event_name != 'pull_request'
        run: |
          APP_PATH="${{ steps.find-app.outputs.app_path }}"

          echo "Verifying code signature..."
          codesign -vvv --deep --strict "$APP_PATH"

          echo ""
          echo "Code signature details:"
          codesign -dvvv "$APP_PATH"

          echo ""
          echo "âœ… Code signature verification successful"

      - name: Verify app bundle
        run: |
          APP_PATH="${{ steps.find-app.outputs.app_path }}"

          if [ ! -d "$APP_PATH" ]; then
            echo "âœ— App bundle not found"
            exit 1
          fi

          echo "âœ“ App bundle exists"
          ls -lh "$APP_PATH"

          if [ ! -f "$APP_PATH/Contents/MacOS/OnCallNotify" ]; then
            echo "âœ— Executable not found"
            exit 1
          fi
          echo "âœ“ Executable found"

          if [ ! -f "$APP_PATH/Contents/Info.plist" ]; then
            echo "âœ— Info.plist not found"
            exit 1
          fi
          echo "âœ“ Info.plist found"

          # List Resources directory contents for debugging
          if [ -d "$APP_PATH/Contents/Resources" ]; then
            echo "Resources directory contents:"
            ls -la "$APP_PATH/Contents/Resources"
          else
            echo "âš  Resources directory not found"
          fi

          # Check for Assets.car (informational only)
          if [ -f "$APP_PATH/Contents/Resources/Assets.car" ]; then
            ASSETS_SIZE=$(stat -f%z "$APP_PATH/Contents/Resources/Assets.car" 2>/dev/null || echo 0)
            echo "âœ“ Assets.car found (${ASSETS_SIZE} bytes)"
          else
            echo "â„¹ Assets.car not found (icons may be embedded differently)"
          fi

          # Verify source icon files exist
          ICON_DIR="OnCallNotify/Assets.xcassets/AppIcon.appiconset"
          if [ ! -d "$ICON_DIR" ]; then
            echo "âœ— Icon directory not found: $ICON_DIR"
            exit 1
          fi

          ICON_COUNT=$(ls -1 "$ICON_DIR"/*.png 2>/dev/null | wc -l | xargs)
          if [ "$ICON_COUNT" -ne 7 ]; then
            echo "âœ— Expected 7 icon files, found $ICON_COUNT"
            exit 1
          fi
          echo "âœ“ All 7 icon source files present"

      - name: Notarize app
        if: github.event_name != 'pull_request'
        env:
          APPLE_ID: ${{ secrets.APPLE_DEVELOPER_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_APP_PASSWORD }}
          TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          APP_PATH="${{ steps.find-app.outputs.app_path }}"

          echo "Creating ZIP for notarization..."
          ditto -c -k --keepParent "$APP_PATH" OnCallNotify.zip

          echo "Submitting to Apple for notarization..."
          echo "This may take several minutes..."

          # Capture the submission output
          SUBMISSION_OUTPUT=$(xcrun notarytool submit OnCallNotify.zip \
            --apple-id "$APPLE_ID" \
            --team-id "$TEAM_ID" \
            --password "$APPLE_PASSWORD" \
            --wait \
            --timeout 30m 2>&1)

          echo "$SUBMISSION_OUTPUT"

          # Extract submission ID
          SUBMISSION_ID=$(echo "$SUBMISSION_OUTPUT" | grep "id:" | head -1 | awk '{print $2}')
          echo "Submission ID: $SUBMISSION_ID"

          # Get detailed notarization log
          echo ""
          echo "=========================================="
          echo "NOTARIZATION LOG:"
          echo "=========================================="
          xcrun notarytool log "$SUBMISSION_ID" \
            --apple-id "$APPLE_ID" \
            --team-id "$TEAM_ID" \
            --password "$APPLE_PASSWORD"
          echo "=========================================="

          # Check if notarization was successful
          if echo "$SUBMISSION_OUTPUT" | grep -q "status: Accepted"; then
            echo ""
            echo "Stapling notarization ticket..."
            xcrun stapler staple "$APP_PATH"

            echo ""
            echo "Verifying notarization..."
            xcrun stapler validate "$APP_PATH"

            echo ""
            echo "âœ… App successfully notarized and stapled"
          else
            echo ""
            echo "âŒ Notarization failed. Check the log above for details."
            exit 1
          fi

          # Clean up ZIP
          rm OnCallNotify.zip

      - name: Create DMG for distribution
        if: github.event_name != 'pull_request'
        env:
          APPLE_ID: ${{ secrets.APPLE_DEVELOPER_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_APP_PASSWORD }}
          TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          APP_PATH="${{ steps.find-app.outputs.app_path }}"

          echo "Creating DMG..."

          # Create a temporary directory for DMG contents
          mkdir -p dmg_contents
          cp -r "$APP_PATH" dmg_contents/

          # Create DMG
          hdiutil create -volname "OnCall Notify" \
            -srcfolder dmg_contents \
            -ov -format UDZO \
            OnCallNotify.dmg

          # Clean up temporary directory
          rm -rf dmg_contents

          echo "âœ… DMG created successfully"

          # Sign the DMG itself
          echo "Signing DMG..."
          codesign -s "$SIGNING_IDENTITY" \
            --timestamp \
            --keychain "$KEYCHAIN_NAME" \
            OnCallNotify.dmg

          echo "âœ… DMG signed"

          # Notarize the DMG
          echo "Submitting DMG to Apple for notarization..."
          echo "This may take several minutes..."

          DMG_SUBMISSION_OUTPUT=$(xcrun notarytool submit OnCallNotify.dmg \
            --apple-id "$APPLE_ID" \
            --team-id "$TEAM_ID" \
            --password "$APPLE_PASSWORD" \
            --wait \
            --timeout 30m 2>&1)

          echo "$DMG_SUBMISSION_OUTPUT"

          # Extract submission ID
          DMG_SUBMISSION_ID=$(echo "$DMG_SUBMISSION_OUTPUT" | grep "id:" | head -1 | awk '{print $2}')
          echo "DMG Submission ID: $DMG_SUBMISSION_ID"

          # Get detailed notarization log
          echo ""
          echo "=========================================="
          echo "DMG NOTARIZATION LOG:"
          echo "=========================================="
          xcrun notarytool log "$DMG_SUBMISSION_ID" \
            --apple-id "$APPLE_ID" \
            --team-id "$TEAM_ID" \
            --password "$APPLE_PASSWORD"
          echo "=========================================="

          if echo "$DMG_SUBMISSION_OUTPUT" | grep -q "status: Accepted"; then
            echo ""
            echo "Stapling notarization to DMG..."
            xcrun stapler staple OnCallNotify.dmg

            echo ""
            echo "Verifying DMG notarization..."
            xcrun stapler validate OnCallNotify.dmg

            echo ""
            echo "âœ… DMG successfully notarized and stapled"
          else
            echo ""
            echo "âŒ DMG notarization failed. Check the log above for details."
            exit 1
          fi

      - name: Create artifact directory
        run: |
          mkdir -p artifacts
          cp -r "${{ steps.find-app.outputs.app_path }}" artifacts/

          # Copy DMG if it exists (signed builds only)
          if [ -f "OnCallNotify.dmg" ]; then
            cp OnCallNotify.dmg artifacts/
            echo "âœ… DMG copied to artifacts"
          fi

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: OnCallNotify-${{ github.event_name != 'pull_request' && 'signed' || 'unsigned' }}-${{ github.sha }}
          path: |
            artifacts/OnCallNotify.app
            artifacts/OnCallNotify.dmg
          retention-days: 30

      - name: Cleanup certificate
        if: always() && github.event_name != 'pull_request'
        run: |
          echo "Cleaning up temporary keychain..."
          if [ ! -z "$KEYCHAIN_NAME" ]; then
            security delete-keychain "$KEYCHAIN_NAME" 2>/dev/null || true
            echo "Temporary keychain deleted"
          else
            echo "No keychain to clean up"
          fi

      - name: Build summary
        run: |
          APP_PATH="${{ steps.find-app.outputs.app_path }}"

          if [ "${{ github.event_name }}" != "pull_request" ]; then
            SIGNED_STATUS="âœ… Signed & Notarized"
          else
            SIGNED_STATUS="âš ï¸ Unsigned (pull request build)"
          fi

          echo "## Build Summary :rocket:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: âœ… Build successful" >> $GITHUB_STEP_SUMMARY
          echo "- **Signing**: $SIGNED_STATUS" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Event**: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Xcode**: $(xcodebuild -version | head -n 1)" >> $GITHUB_STEP_SUMMARY
          echo "- **Swift**: $(swift --version | head -n 1)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### App Details" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Bundle ID**: $(defaults read "$APP_PATH/Contents/Info.plist" CFBundleIdentifier)" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: $(defaults read "$APP_PATH/Contents/Info.plist" CFBundleShortVersionString)" >> $GITHUB_STEP_SUMMARY
          echo "- **Build**: $(defaults read "$APP_PATH/Contents/Info.plist" CFBundleVersion)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ github.event_name }}" != "pull_request" ]; then
            echo "### ðŸ” Security" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "- Code signed with Developer ID" >> $GITHUB_STEP_SUMMARY
            echo "- Notarized by Apple" >> $GITHUB_STEP_SUMMARY
            echo "- DMG created and notarized" >> $GITHUB_STEP_SUMMARY
            if [ "${{ github.ref }}" == "refs/heads/main" ]; then
              echo "- Ready for production distribution" >> $GITHUB_STEP_SUMMARY
            else
              echo "- Ready for testing and development" >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### ðŸ“¦ Distribution" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Download the DMG file** from the artifacts for distribution." >> $GITHUB_STEP_SUMMARY
            echo "The DMG is properly signed and notarized - users won't see security warnings." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          echo "ðŸ“¦ Build artifacts uploaded and available for download." >> $GITHUB_STEP_SUMMARY
