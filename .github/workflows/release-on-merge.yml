name: Release on Merge to Main

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      version:
        description: "Version to release (e.g., 1.2.3 or leave empty for auto-bump)"
        required: false
        type: string

# Important: These permissions ensure secrets are only accessible on main branch
permissions:
  id-token: write
  contents: write
  packages: write

jobs:
  release:
    name: Create Release
    runs-on: macos-latest
    # Extra security: only run on push to main (not PRs) or manual dispatch
    if: (github.event_name == 'push' && github.ref == 'refs/heads/main') || github.event_name == 'workflow_dispatch'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          # Use a PAT or default token with write permissions
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure git for bot commits
        run: |
          git config user.name "GitHubActions"
          git config user.email "github@unicornops.ie"

      - name: Determine version strategy
        id: version_strategy
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ] && [ -n "${{ inputs.version }}" ]; then
            echo "strategy=manual" >> $GITHUB_OUTPUT
            echo "Manual version specified: ${{ inputs.version }}"
          else
            echo "strategy=auto" >> $GITHUB_OUTPUT
            echo "Auto-bump version from conventional commits"
          fi

      - name: Check for conventional commits
        if: steps.version_strategy.outputs.strategy == 'auto'
        uses: cocogitto/cocogitto-action@v4
        with:
          command: check
          args: --from-latest-tag
        continue-on-error: true

      - name: Get next version
        if: steps.version_strategy.outputs.strategy == 'auto'
        id: next_version
        run: |
          NEXT_VERSION=$(cog bump --auto --dry-run 2>&1 || echo "none")
          if [ "$NEXT_VERSION" == "none" ] || echo "$NEXT_VERSION" | grep -q "No conventional commits"; then
            echo "No new version to bump - no conventional commits found"
            echo "next_version=none" >> $GITHUB_OUTPUT
            exit 1
          fi
          echo "next_version=$NEXT_VERSION" >> $GITHUB_OUTPUT
          echo "Next version will be: $NEXT_VERSION"

      - name: Cocogitto bump
        if: steps.version_strategy.outputs.strategy == 'auto' && steps.next_version.outputs.next_version != 'none'
        id: bump_auto
        uses: cocogitto/cocogitto-action@v4
        with:
          command: bump
          args: --auto
          git-user: "GitHubActions"
          git-user-email: "github@unicornops.ie"

      - name: Create manual version tag
        if: steps.version_strategy.outputs.strategy == 'manual'
        id: bump_manual
        run: |
          VERSION="${{ inputs.version }}"
          # Add 'v' prefix if not present
          if [[ ! "$VERSION" =~ ^v ]]; then
            VERSION="v${VERSION}"
          fi

          echo "Creating manual tag: $VERSION"
          git tag -a "$VERSION" -m "chore(release): $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Set bump output
        id: bump
        run: |
          if [ "${{ steps.version_strategy.outputs.strategy }}" == "manual" ]; then
            echo "version=${{ steps.bump_manual.outputs.version }}" >> $GITHUB_OUTPUT
          else
            echo "version=${{ steps.bump_auto.outputs.version }}" >> $GITHUB_OUTPUT
          fi

      - name: Push tags
        run: |
          git push --follow-tags

      - name: Generate changelog for release
        run: |
          VERSION="${{ steps.bump.outputs.version }}"
          if [ "${{ steps.version_strategy.outputs.strategy }}" == "manual" ]; then
            # For manual releases, generate changelog from latest tag
            echo "# Manual Release" > GITHUB_CHANGELOG.md
            echo "" >> GITHUB_CHANGELOG.md
            echo "This is a manually triggered release." >> GITHUB_CHANGELOG.md
            echo "" >> GITHUB_CHANGELOG.md
            echo "## Recent Changes" >> GITHUB_CHANGELOG.md
            echo "" >> GITHUB_CHANGELOG.md
            cog changelog --at "$VERSION" -t full_hash >> GITHUB_CHANGELOG.md 2>&1 || \
            git log --pretty=format:"- %s (%h)" $(git describe --tags --abbrev=0 2>/dev/null || echo HEAD~10)..HEAD >> GITHUB_CHANGELOG.md
          else
            cog changelog \
              --at "$VERSION" \
              -t full_hash \
              > GITHUB_CHANGELOG.md
          fi

      - name: Show build environment
        run: |
          echo "Xcode version:"
          xcodebuild -version
          echo ""
          echo "Swift version:"
          swift --version
          echo ""
          echo "macOS version:"
          sw_vers

      - name: Set version for build
        id: version
        run: |
          VERSION="${{ steps.bump.outputs.version }}"
          # Remove 'v' prefix if present
          VERSION="${VERSION#v}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Building version: $VERSION"

      - name: Clean build directory
        run: rm -rf build/

      - name: Setup code signing
        if: github.event_name != 'pull_request'
        env:
          CERTIFICATE_BASE64: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}
          CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          # Create a temporary keychain with a password we control
          KEYCHAIN_NAME="build.keychain"
          KEYCHAIN_PASSWORD="temporary_password_$(uuidgen)"
          KEYCHAIN_PATH="$HOME/Library/Keychains/$KEYCHAIN_NAME-db"

          echo "Creating temporary keychain..."
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"

          # Set keychain settings - no timeout, no lock
          echo "Configuring keychain settings..."
          security set-keychain-settings "$KEYCHAIN_NAME"

          # Unlock the keychain
          echo "Unlocking keychain..."
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"

          # Add to keychain search list
          echo "Adding to keychain search list..."
          security list-keychains -d user -s "$KEYCHAIN_NAME" $(security list-keychains -d user | sed s/\"//g)

          # Import certificate
          echo "Importing certificate..."
          CERTIFICATE_PATH=$RUNNER_TEMP/certificate.p12
          echo "$CERTIFICATE_BASE64" | base64 --decode > "$CERTIFICATE_PATH"

          # Verify certificate file was created
          if [ ! -f "$CERTIFICATE_PATH" ]; then
            echo "Error: Certificate file was not created"
            exit 1
          fi

          echo "Certificate file size: $(ls -lh "$CERTIFICATE_PATH" | awk '{print $5}')"

          # Verify it's a valid PKCS12 file
          if ! file "$CERTIFICATE_PATH" | grep -q "data"; then
            echo "Error: Certificate file doesn't appear to be valid"
            file "$CERTIFICATE_PATH"
            exit 1
          fi

          # Import certificate with -T flags for codesign and security tools
          echo "Importing certificate to keychain..."
          security import "$CERTIFICATE_PATH" \
            -P "$CERTIFICATE_PASSWORD" \
            -A \
            -t cert \
            -f pkcs12 \
            -k "$KEYCHAIN_NAME" \
            -T /usr/bin/codesign \
            -T /usr/bin/security || {
              echo "Error: Certificate import failed"
              echo "This usually means:"
              echo "1. APPLE_CERTIFICATE_PASSWORD is incorrect"
              echo "2. APPLE_CERTIFICATE_BASE64 is not a valid .p12 file"
              echo "3. The certificate doesn't contain a private key"
              exit 1
            }

          # Set partition list to allow access without password prompt
          echo "Setting partition list for codesign access..."
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"

          # Verify certificate and get exact identity
          echo "Installed certificates:"
          security find-identity -v -p codesigning "$KEYCHAIN_NAME"

          # Count how many identities we have
          IDENTITY_COUNT=$(security find-identity -v -p codesigning "$KEYCHAIN_NAME" | grep -c "Developer ID Application" || echo "0")
          echo "Found $IDENTITY_COUNT Developer ID Application certificate(s)"

          if [ "$IDENTITY_COUNT" -eq "0" ]; then
            echo "Error: No Developer ID Application certificate found after import"
            echo "The certificate import succeeded but no codesigning identity is available"
            echo "Please verify your certificate export includes the private key"
            exit 1
          fi

          # Extract the exact identity for use in xcodebuild
          IDENTITY=$(security find-identity -v -p codesigning "$KEYCHAIN_NAME" | grep "Developer ID Application" | head -1 | sed -n 's/.*"\(.*\)"/\1/p')
          echo "Found identity: $IDENTITY"

          if [ -z "$IDENTITY" ]; then
            echo "Error: Could not extract identity name"
            exit 1
          fi

          # Extract team ID from identity string (it's in parentheses)
          # Example: "Developer ID Application: Company Name (TEAM123)" -> "TEAM123"
          echo "Extracting team ID from identity string..."
          CERT_TEAM_ID=$(echo "$IDENTITY" | sed -n 's/.*(\([^)]*\)).*/\1/p')

          if [ -z "$CERT_TEAM_ID" ]; then
            echo "Warning: Could not extract team ID from identity, using provided value"
            CERT_TEAM_ID="$TEAM_ID"
          else
            echo "Extracted team ID from identity: $CERT_TEAM_ID"
          fi

          # Store the exact identity name, team ID, and keychain info for the build step
          echo "SIGNING_IDENTITY=$IDENTITY" >> $GITHUB_ENV
          echo "CERT_TEAM_ID=$CERT_TEAM_ID" >> $GITHUB_ENV
          echo "KEYCHAIN_NAME=$KEYCHAIN_NAME" >> $GITHUB_ENV
          echo "KEYCHAIN_PASSWORD=$KEYCHAIN_PASSWORD" >> $GITHUB_ENV

          echo "âœ… Code signing certificate installed"

      - name: Build and sign release
        if: github.event_name != 'pull_request'
        run: |
          echo "Building with Developer ID Application certificate for team: $CERT_TEAM_ID"

          # Verify certificate is accessible
          echo "Verifying certificate in login keychain:"
          security find-identity -v -p codesigning

          echo "Using signing identity: $SIGNING_IDENTITY"
          echo "Using team ID: $CERT_TEAM_ID"

          # Unlock keychain before build (in case it locked)
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"

          # Build with signing
          xcodebuild \
            -project OnCallNotify.xcodeproj \
            -scheme OnCallNotify \
            -configuration Release \
            -derivedDataPath build/DerivedData \
            CODE_SIGN_IDENTITY="$SIGNING_IDENTITY" \
            CODE_SIGN_STYLE=Manual \
            DEVELOPMENT_TEAM="$CERT_TEAM_ID" \
            ENABLE_HARDENED_RUNTIME=YES \
            CODE_SIGN_ENTITLEMENTS="OnCallNotify/OnCallNotify.entitlements" \
            CODE_SIGN_INJECT_BASE_ENTITLEMENTS=NO \
            OTHER_CODE_SIGN_FLAGS="--keychain $KEYCHAIN_NAME --options runtime --timestamp" \
            build

      - name: Find built app
        id: find-app
        run: |
          APP_PATH=$(find build -name "OnCallNotify.app" -type d | head -n 1)
          if [ -z "$APP_PATH" ]; then
            echo "Error: OnCallNotify.app not found in build directory"
            exit 1
          fi
          # Convert to absolute path
          APP_PATH=$(cd "$(dirname "$APP_PATH")" && pwd)/$(basename "$APP_PATH")
          echo "app_path=$APP_PATH" >> $GITHUB_OUTPUT
          echo "Found app at: $APP_PATH"

          # Verify Info.plist exists
          if [ ! -f "$APP_PATH/Contents/Info.plist" ]; then
            echo "Error: Info.plist not found at $APP_PATH/Contents/Info.plist"
            exit 1
          fi

      - name: Verify app bundle
        run: |
          APP_PATH="${{ steps.find-app.outputs.app_path }}"

          if [ ! -d "$APP_PATH" ]; then
            echo "Error: App bundle not found"
            exit 1
          fi

          echo "App bundle structure:"
          ls -lhR "$APP_PATH"

          if [ ! -f "$APP_PATH/Contents/MacOS/OnCallNotify" ]; then
            echo "Error: Executable not found"
            exit 1
          fi

          if [ ! -f "$APP_PATH/Contents/Info.plist" ]; then
            echo "Error: Info.plist not found"
            exit 1
          fi

          echo "âœ“ App bundle verification successful"

      - name: Verify code signature
        run: |
          APP_PATH="${{ steps.find-app.outputs.app_path }}"

          echo "Verifying code signature..."
          codesign -vvv --deep --strict "$APP_PATH"

          echo ""
          echo "Code signature details:"
          codesign -dvvv "$APP_PATH"

          echo ""
          echo "âœ… Code signature verification successful"

      - name: Notarize app
        env:
          APPLE_ID: ${{ secrets.APPLE_DEVELOPER_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_APP_PASSWORD }}
          TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          APP_PATH="${{ steps.find-app.outputs.app_path }}"

          echo "Creating ZIP for notarization..."
          ditto -c -k --keepParent "$APP_PATH" NotarizeApp.zip

          echo "Submitting to Apple for notarization..."
          echo "This may take several minutes..."
          xcrun notarytool submit NotarizeApp.zip \
            --apple-id "$APPLE_ID" \
            --team-id "$TEAM_ID" \
            --password "$APPLE_PASSWORD" \
            --wait \
            --timeout 30m

          echo ""
          echo "Stapling notarization ticket..."
          xcrun stapler staple "$APP_PATH"

          echo ""
          echo "Verifying notarization..."
          xcrun stapler validate "$APP_PATH"
          spctl -a -vv "$APP_PATH"

          echo ""
          echo "âœ… App successfully notarized and stapled"

          # Clean up notarization ZIP
          rm NotarizeApp.zip

      - name: Get app info
        id: app-info
        run: |
          APP_PATH="${{ steps.find-app.outputs.app_path }}"
          PLIST_PATH="$APP_PATH/Contents/Info.plist"

          echo "Reading from: $PLIST_PATH"

          # Use PlistBuddy for more reliable plist reading
          BUNDLE_ID=$(/usr/libexec/PlistBuddy -c "Print :CFBundleIdentifier" "$PLIST_PATH")
          BUNDLE_VERSION=$(/usr/libexec/PlistBuddy -c "Print :CFBundleShortVersionString" "$PLIST_PATH")
          BUNDLE_BUILD=$(/usr/libexec/PlistBuddy -c "Print :CFBundleVersion" "$PLIST_PATH")

          echo "bundle_id=$BUNDLE_ID" >> $GITHUB_OUTPUT
          echo "bundle_version=$BUNDLE_VERSION" >> $GITHUB_OUTPUT
          echo "bundle_build=$BUNDLE_BUILD" >> $GITHUB_OUTPUT

          echo "Bundle ID: $BUNDLE_ID"
          echo "Version: $BUNDLE_VERSION"
          echo "Build: $BUNDLE_BUILD"

      - name: Create DMG
        run: |
          APP_PATH="${{ steps.find-app.outputs.app_path }}"
          VERSION="${{ steps.version.outputs.version }}"
          DMG_NAME="OnCallNotify-${VERSION}.dmg"
          VOLUME_NAME="OnCall Notify ${VERSION}"

          # Use the custom DMG creation script
          ./create-dmg.sh "$APP_PATH" "$DMG_NAME" "$VOLUME_NAME"

          # Verify DMG was created
          if [ -f "$DMG_NAME" ]; then
            echo "âœ“ DMG created successfully: $DMG_NAME"
            ls -lh "$DMG_NAME"
          else
            echo "âœ— DMG creation failed"
            exit 1
          fi

          # Save DMG name for later steps
          echo "dmg_name=$DMG_NAME" >> $GITHUB_OUTPUT
        id: create-dmg

      - name: Create ZIP archive
        run: |
          APP_PATH="${{ steps.find-app.outputs.app_path }}"
          VERSION="${{ steps.version.outputs.version }}"
          ZIP_NAME="OnCallNotify-${VERSION}.zip"

          # Create ZIP archive
          ditto -c -k --keepParent "$APP_PATH" "$ZIP_NAME"

          # Verify ZIP was created
          if [ -f "$ZIP_NAME" ]; then
            echo "âœ“ ZIP created successfully: $ZIP_NAME"
            ls -lh "$ZIP_NAME"
          else
            echo "âœ— ZIP creation failed"
            exit 1
          fi

          echo "zip_name=$ZIP_NAME" >> $GITHUB_OUTPUT
        id: create-zip

      - name: Calculate checksums
        run: |
          DMG_NAME="${{ steps.create-dmg.outputs.dmg_name }}"
          ZIP_NAME="${{ steps.create-zip.outputs.zip_name }}"

          echo "Calculating checksums..."
          shasum -a 256 "$DMG_NAME" > checksums.txt
          shasum -a 256 "$ZIP_NAME" >> checksums.txt

          echo "Checksums:"
          cat checksums.txt

      - name: Cleanup certificate
        if: always()
        run: |
          echo "Cleaning up imported certificate from login keychain..."
          security find-identity -v -p codesigning | grep "Developer ID Application: Unicorn Operations" | while read line; do
            HASH=$(echo "$line" | awk '{print $2}')
            if [ ! -z "$HASH" ]; then
              echo "Removing certificate: $HASH"
              security delete-identity -Z "$HASH" 2>/dev/null || true
            fi
          done
          echo "Certificate cleanup complete"

      - name: Create Release Notes
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          BUNDLE_VERSION="${{ steps.app-info.outputs.bundle_version }}"
          BUNDLE_BUILD="${{ steps.app-info.outputs.bundle_build }}"

          cat > release-notes.md << EOF
          # OnCall Notify v${VERSION}

          ## ðŸ“‹ Changelog

          $(cat GITHUB_CHANGELOG.md)

          ---

          ## ðŸ“¦ Installation

          ### Option 1: DMG Installer (Recommended)
          1. Download \`OnCallNotify-${VERSION}.dmg\`
          2. Open the DMG file
          3. Drag OnCall Notify to your Applications folder
          4. Launch from Applications

          ### Option 2: ZIP Archive
          1. Download \`OnCallNotify-${VERSION}.zip\`
          2. Extract the ZIP file
          3. Move OnCallNotify.app to your Applications folder
          4. Launch from Applications

          ## â„¹ï¸ Build Information

          - **Version**: ${BUNDLE_VERSION}
          - **Build**: ${BUNDLE_BUILD}
          - **macOS**: 13.0+ (Ventura or later)
          - **Architecture**: Universal (Apple Silicon & Intel)

          ## ðŸ” Security

          This release is **fully signed and notarized** by Apple:
          - âœ… Code signed with Developer ID
          - âœ… Notarized by Apple
          - âœ… No security warnings on macOS

          Simply download, install, and run. No special steps required!

          ## ðŸ“ Checksums (SHA-256)

          \`\`\`
          $(cat checksums.txt)
          \`\`\`

          ## ðŸš€ Quick Start

          1. Launch OnCall Notify
          2. Click the menu bar icon
          3. Click the gear icon to open Settings
          4. Enter your PagerDuty API token
          5. Click "Test Connection" to verify

          For more details, see the [Quick Start Guide](https://github.com/${{ github.repository }}/blob/main/QUICKSTART.md).
          EOF

          cat release-notes.md

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.bump.outputs.version }}
          body_path: release-notes.md
          files: |
            ${{ steps.create-dmg.outputs.dmg_name }}
            ${{ steps.create-zip.outputs.zip_name }}
            checksums.txt
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Release summary
        run: |
          VERSION="${{ steps.version.outputs.version }}"

          echo "## Release Build Summary ðŸŽ‰" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: ${{ steps.bump.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Bundle Version**: ${{ steps.app-info.outputs.bundle_version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Bundle Build**: ${{ steps.app-info.outputs.bundle_build }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Xcode**: $(xcodebuild -version | head -n 1)" >> $GITHUB_STEP_SUMMARY
          echo "- **Swift**: $(swift --version | head -n 1)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ” Security" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Code signed with Developer ID" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Notarized by Apple" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Ready for public distribution" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“¦ Release Created" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- Tag: \`${{ steps.bump.outputs.version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- DMG: \`${{ steps.create-dmg.outputs.dmg_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- ZIP: \`${{ steps.create-zip.outputs.zip_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ðŸŽ‰ **Release published**: https://github.com/${{ github.repository }}/releases/tag/${{ steps.bump.outputs.version }}" >> $GITHUB_STEP_SUMMARY
