name: Release on Merge to Main

on:
  push:
    branches:
      - main

# Important: These permissions ensure secrets are only accessible on main branch
permissions:
  id-token: write
  contents: write
  packages: write

jobs:
  release:
    name: Create Release
    runs-on: macos-latest
    # Extra security: only run on push to main (not PRs)
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          # Use a PAT or default token with write permissions
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure git for bot commits
        run: |
          git config user.name "GitHubActions"
          git config user.email "github@unicornops.ie"

      - name: Check for conventional commits
        uses: cocogitto/cocogitto-action@v4
        with:
          command: check
          args: --from-latest-tag

      - name: Get next version
        id: next_version
        run: |
          NEXT_VERSION=$(cog bump --auto --dry-run)
          echo "next_version=$NEXT_VERSION" >> $GITHUB_OUTPUT
          echo "Next version will be: $NEXT_VERSION"

      - name: Cocogitto bump
        id: bump
        uses: cocogitto/cocogitto-action@v4
        with:
          command: bump
          args: --auto
          git-user: "GitHubActions"
          git-user-email: "github@unicornops.ie"

      - name: Push tags
        run: |
          git push --follow-tags

      - name: Generate changelog for release
        run: |
          cog changelog \
            --at "${{ steps.bump.outputs.version }}" \
            -t full_hash \
            > GITHUB_CHANGELOG.md

      - name: Show build environment
        run: |
          echo "Xcode version:"
          xcodebuild -version
          echo ""
          echo "Swift version:"
          swift --version
          echo ""
          echo "macOS version:"
          sw_vers

      - name: Set version for build
        id: version
        run: |
          VERSION="${{ steps.bump.outputs.version }}"
          # Remove 'v' prefix if present
          VERSION="${VERSION#v}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Building version: $VERSION"

      - name: Clean build directory
        run: rm -rf build/

      - name: Setup code signing
        env:
          CERTIFICATE_BASE64: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}
          CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          # Use login keychain instead of temporary for xcodebuild compatibility
          KEYCHAIN_PATH="$HOME/Library/Keychains/login.keychain-db"

          echo "Using login keychain for certificate import..."
          echo "Keychain path: $KEYCHAIN_PATH"

          # Import certificate
          echo "Importing certificate..."
          CERTIFICATE_PATH=$RUNNER_TEMP/certificate.p12
          echo "$CERTIFICATE_BASE64" | base64 --decode > "$CERTIFICATE_PATH"

          # Verify certificate file was created
          if [ ! -f "$CERTIFICATE_PATH" ]; then
            echo "Error: Certificate file was not created"
            exit 1
          fi

          echo "Certificate file size: $(ls -lh "$CERTIFICATE_PATH" | awk '{print $5}')"

          # Verify it's a valid PKCS12 file
          if ! file "$CERTIFICATE_PATH" | grep -q "data"; then
            echo "Error: Certificate file doesn't appear to be valid"
            file "$CERTIFICATE_PATH"
            exit 1
          fi

          # Import certificate to login keychain
          echo "Importing certificate to login keychain..."
          security import "$CERTIFICATE_PATH" \
            -P "$CERTIFICATE_PASSWORD" \
            -A \
            -t cert \
            -f pkcs12 \
            -k "$KEYCHAIN_PATH" 2>&1 || {
              echo "Error: Certificate import failed"
              exit 1
            }

          # Set partition list to allow codesigning
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "" "$KEYCHAIN_PATH" 2>/dev/null || \
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s "$KEYCHAIN_PATH" 2>/dev/null || \
          echo "Note: Could not set partition list, but certificate may still work"

          # Verify certificate and get exact identity
          echo "Installed certificates:"
          security find-identity -v -p codesigning "$KEYCHAIN_PATH"

          # Count how many identities we have
          IDENTITY_COUNT=$(security find-identity -v -p codesigning "$KEYCHAIN_PATH" | grep -c "Developer ID Application" || echo "0")
          echo "Found $IDENTITY_COUNT Developer ID Application certificate(s)"

          if [ "$IDENTITY_COUNT" -eq "0" ]; then
            echo "Error: No Developer ID Application certificate found after import"
            exit 1
          fi

          # Extract the exact identity for use in xcodebuild
          IDENTITY=$(security find-identity -v -p codesigning "$KEYCHAIN_PATH" | grep "Developer ID Application" | head -1 | sed -n 's/.*"\(.*\)"/\1/p')
          echo "Found identity: $IDENTITY"

          if [ -z "$IDENTITY" ]; then
            echo "Error: Could not extract identity name"
            exit 1
          fi

          # Store the exact identity name for the build step
          echo "SIGNING_IDENTITY=$IDENTITY" >> $GITHUB_ENV

          echo "âœ… Code signing certificate installed"

      - name: Build and sign release
        env:
          TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          echo "Building with Developer ID Application certificate for team: $TEAM_ID"

          # Verify certificate is accessible
          echo "Verifying certificate in login keychain:"
          security find-identity -v -p codesigning

          echo "Using signing identity: $SIGNING_IDENTITY"

          # Build with signing
          xcodebuild \
            -project OnCallNotify.xcodeproj \
            -scheme OnCallNotify \
            -configuration Release \
            -derivedDataPath build/DerivedData \
            SYMROOT=build \
            CODE_SIGN_IDENTITY="$SIGNING_IDENTITY" \
            CODE_SIGN_STYLE=Manual \
            DEVELOPMENT_TEAM="$TEAM_ID" \
            clean build

      - name: Find built app
        id: find-app
        run: |
          APP_PATH=$(find build -name "OnCallNotify.app" -type d | head -n 1)
          echo "app_path=$APP_PATH" >> $GITHUB_OUTPUT
          echo "Found app at: $APP_PATH"

      - name: Verify app bundle
        run: |
          APP_PATH="${{ steps.find-app.outputs.app_path }}"

          if [ ! -d "$APP_PATH" ]; then
            echo "Error: App bundle not found"
            exit 1
          fi

          echo "App bundle structure:"
          ls -lhR "$APP_PATH"

          if [ ! -f "$APP_PATH/Contents/MacOS/OnCallNotify" ]; then
            echo "Error: Executable not found"
            exit 1
          fi

          if [ ! -f "$APP_PATH/Contents/Info.plist" ]; then
            echo "Error: Info.plist not found"
            exit 1
          fi

          echo "âœ“ App bundle verification successful"

      - name: Verify code signature
        run: |
          APP_PATH="${{ steps.find-app.outputs.app_path }}"

          echo "Verifying code signature..."
          codesign -vvv --deep --strict "$APP_PATH"

          echo ""
          echo "Code signature details:"
          codesign -dvvv "$APP_PATH"

          echo ""
          echo "âœ… Code signature verification successful"

      - name: Notarize app
        env:
          APPLE_ID: ${{ secrets.APPLE_DEVELOPER_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_APP_PASSWORD }}
          TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          APP_PATH="${{ steps.find-app.outputs.app_path }}"

          echo "Creating ZIP for notarization..."
          ditto -c -k --keepParent "$APP_PATH" NotarizeApp.zip

          echo "Submitting to Apple for notarization..."
          echo "This may take several minutes..."
          xcrun notarytool submit NotarizeApp.zip \
            --apple-id "$APPLE_ID" \
            --team-id "$TEAM_ID" \
            --password "$APPLE_PASSWORD" \
            --wait \
            --timeout 30m

          echo ""
          echo "Stapling notarization ticket..."
          xcrun stapler staple "$APP_PATH"

          echo ""
          echo "Verifying notarization..."
          xcrun stapler validate "$APP_PATH"
          spctl -a -vv "$APP_PATH"

          echo ""
          echo "âœ… App successfully notarized and stapled"

          # Clean up notarization ZIP
          rm NotarizeApp.zip

      - name: Get app info
        id: app-info
        run: |
          APP_PATH="${{ steps.find-app.outputs.app_path }}"
          BUNDLE_ID=$(defaults read "$APP_PATH/Contents/Info.plist" CFBundleIdentifier)
          BUNDLE_VERSION=$(defaults read "$APP_PATH/Contents/Info.plist" CFBundleShortVersionString)
          BUNDLE_BUILD=$(defaults read "$APP_PATH/Contents/Info.plist" CFBundleVersion)

          echo "bundle_id=$BUNDLE_ID" >> $GITHUB_OUTPUT
          echo "bundle_version=$BUNDLE_VERSION" >> $GITHUB_OUTPUT
          echo "bundle_build=$BUNDLE_BUILD" >> $GITHUB_OUTPUT

          echo "Bundle ID: $BUNDLE_ID"
          echo "Version: $BUNDLE_VERSION"
          echo "Build: $BUNDLE_BUILD"

      - name: Create DMG
        run: |
          APP_PATH="${{ steps.find-app.outputs.app_path }}"
          VERSION="${{ steps.version.outputs.version }}"
          DMG_NAME="OnCallNotify-${VERSION}.dmg"
          VOLUME_NAME="OnCall Notify ${VERSION}"

          # Use the custom DMG creation script
          ./create-dmg.sh "$APP_PATH" "$DMG_NAME" "$VOLUME_NAME"

          # Verify DMG was created
          if [ -f "$DMG_NAME" ]; then
            echo "âœ“ DMG created successfully: $DMG_NAME"
            ls -lh "$DMG_NAME"
          else
            echo "âœ— DMG creation failed"
            exit 1
          fi

          # Save DMG name for later steps
          echo "dmg_name=$DMG_NAME" >> $GITHUB_OUTPUT
        id: create-dmg

      - name: Create ZIP archive
        run: |
          APP_PATH="${{ steps.find-app.outputs.app_path }}"
          VERSION="${{ steps.version.outputs.version }}"
          ZIP_NAME="OnCallNotify-${VERSION}.zip"

          # Create ZIP archive
          ditto -c -k --keepParent "$APP_PATH" "$ZIP_NAME"

          # Verify ZIP was created
          if [ -f "$ZIP_NAME" ]; then
            echo "âœ“ ZIP created successfully: $ZIP_NAME"
            ls -lh "$ZIP_NAME"
          else
            echo "âœ— ZIP creation failed"
            exit 1
          fi

          echo "zip_name=$ZIP_NAME" >> $GITHUB_OUTPUT
        id: create-zip

      - name: Calculate checksums
        run: |
          DMG_NAME="${{ steps.create-dmg.outputs.dmg_name }}"
          ZIP_NAME="${{ steps.create-zip.outputs.zip_name }}"

          echo "Calculating checksums..."
          shasum -a 256 "$DMG_NAME" > checksums.txt
          shasum -a 256 "$ZIP_NAME" >> checksums.txt

          echo "Checksums:"
          cat checksums.txt

      - name: Cleanup certificate
        if: always()
        run: |
          echo "Cleaning up imported certificate from login keychain..."
          security find-identity -v -p codesigning | grep "Developer ID Application: Unicorn Operations" | while read line; do
            HASH=$(echo "$line" | awk '{print $2}')
            if [ ! -z "$HASH" ]; then
              echo "Removing certificate: $HASH"
              security delete-identity -Z "$HASH" 2>/dev/null || true
            fi
          done
          echo "Certificate cleanup complete"

      - name: Create Release Notes
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          BUNDLE_VERSION="${{ steps.app-info.outputs.bundle_version }}"
          BUNDLE_BUILD="${{ steps.app-info.outputs.bundle_build }}"

          cat > release-notes.md << EOF
          # OnCall Notify v${VERSION}

          ## ðŸ“‹ Changelog

          $(cat GITHUB_CHANGELOG.md)

          ---

          ## ðŸ“¦ Installation

          ### Option 1: DMG Installer (Recommended)
          1. Download \`OnCallNotify-${VERSION}.dmg\`
          2. Open the DMG file
          3. Drag OnCall Notify to your Applications folder
          4. Launch from Applications

          ### Option 2: ZIP Archive
          1. Download \`OnCallNotify-${VERSION}.zip\`
          2. Extract the ZIP file
          3. Move OnCallNotify.app to your Applications folder
          4. Launch from Applications

          ## â„¹ï¸ Build Information

          - **Version**: ${BUNDLE_VERSION}
          - **Build**: ${BUNDLE_BUILD}
          - **macOS**: 13.0+ (Ventura or later)
          - **Architecture**: Universal (Apple Silicon & Intel)

          ## ðŸ” Security

          This release is **fully signed and notarized** by Apple:
          - âœ… Code signed with Developer ID
          - âœ… Notarized by Apple
          - âœ… No security warnings on macOS

          Simply download, install, and run. No special steps required!

          ## ðŸ“ Checksums (SHA-256)

          \`\`\`
          $(cat checksums.txt)
          \`\`\`

          ## ðŸš€ Quick Start

          1. Launch OnCall Notify
          2. Click the menu bar icon
          3. Click the gear icon to open Settings
          4. Enter your PagerDuty API token
          5. Click "Test Connection" to verify

          For more details, see the [Quick Start Guide](https://github.com/${{ github.repository }}/blob/main/QUICKSTART.md).
          EOF

          cat release-notes.md

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.bump.outputs.version }}
          body_path: release-notes.md
          files: |
            ${{ steps.create-dmg.outputs.dmg_name }}
            ${{ steps.create-zip.outputs.zip_name }}
            checksums.txt
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Release summary
        run: |
          VERSION="${{ steps.version.outputs.version }}"

          echo "## Release Build Summary ðŸŽ‰" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: ${{ steps.bump.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Bundle Version**: ${{ steps.app-info.outputs.bundle_version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Bundle Build**: ${{ steps.app-info.outputs.bundle_build }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Xcode**: $(xcodebuild -version | head -n 1)" >> $GITHUB_STEP_SUMMARY
          echo "- **Swift**: $(swift --version | head -n 1)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ” Security" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Code signed with Developer ID" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Notarized by Apple" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Ready for public distribution" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“¦ Release Created" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- Tag: \`${{ steps.bump.outputs.version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- DMG: \`${{ steps.create-dmg.outputs.dmg_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- ZIP: \`${{ steps.create-zip.outputs.zip_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ðŸŽ‰ **Release published**: https://github.com/${{ github.repository }}/releases/tag/${{ steps.bump.outputs.version }}" >> $GITHUB_STEP_SUMMARY
